#!/usr/bin/env bash

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

# Prevent doublesourcing
if [ -z "$BASHRCSOURCED" ]; then
  BASHRCSOURCED="Y"

  # colorize
  RESET="$(tput sgr0 2>/dev/null)"
  BLACK="$(printf '%b' "\033[0;30m")"
  RED="$(printf '%b' "\033[1;31m")"
  GREEN="$(printf '%b' "\033[0;32m")"
  YELLOW="$(printf '%b' "\033[0;33m")"
  BLUE="$(printf '%b' "\033[0;34m")"
  PURPLE="$(printf '%b' "\033[0;35m")"
  CYAN="$(printf '%b' "\033[0;36m")"
  WHITE="$(printf '%b' "\033[0;37m")"
  ORANGE="$(printf '%b' "\033[0;33m")"
  LIGHTRED="$(printf '%b' '\033[1;31m')"
  BG_GREEN="\[$(tput setab 2 2>/dev/null)\]"
  BG_RED="\[$(tput setab 9 2>/dev/null)\]"

  # set default prompt
  unset PROMPT_COMMAND PS1

  # set title
  __ps1_set_title() {
    echo -ne "${USER}@${HOSTNAME}:${PWD//$HOME/\~}"
  }

  # prompt prev exit status
  __ps1_promp_command() {
    local retVal=$?
    if [ $retVal = 0 ]; then
      PS1="${RED}[\v]:${GREEN}[\u]@[\H]${RESET}:${YELLOW}[\w]${RESET}:${GREEN}[$retVal]${RESET}${BLACK}🐚${RESET}"
    else
      PS1="${RED}[\v]:${GREEN}[\u]@[\H]${RESET}:${YELLOW}[\w]${RESET}:${RED}[$retVal]${RESET}${BLACK}🐚${RESET}"
    fi
    return $retVal
  }

  export PS2="⚡ "
  export PS4="$(
    tput cr 2>/dev/null
    tput cuf 6 2>/dev/null
    printf "${GREEN}+%s ($LINENO) +" " $RESET"
  )"

  # are we an interactive shell?
  if [ -n "$PS1" ]; then
    if [ -z "$PROMPT_COMMAND" ]; then
      PROMPT_COMMAND="PS1=;__ps1_promp_command;__ps1_set_title;history -a && history -r"
    fi
    # Turn on parallel history
    shopt -s histappend
    history -a
    PROMPT_COMMAND="$PROMPT_COMMAND "
    # Turn on checkwinsize
    shopt -s checkwinsize
  fi

  if ! shopt -q login_shell; then # We're not a login shell
    # Need to redefine pathmunge, it gets undefined at the end of /etc/profile
    pathmunge() {
      case ":${PATH}:" in
      *:"$1":*) ;;
      *)
        if [ "$2" = "after" ]; then
          PATH=$PATH:$1
        else
          PATH=$1:$PATH
        fi
        ;;
      esac
    }

    # By default, we want umask to get set. This sets it for non-login shell.
    # Current threshold for system reserved uid/gids is 200
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 199 ] && [ "$(/usr/bin/id -gn)" = "$(/usr/bin/id -un)" ]; then
      umask 002
    else
      umask 022
    fi

    SHELL=/bin/bash
    # Only display echos from profile.d scripts if we are no login shell
    # and interactive - otherwise just process them to set envvars
    for i in /etc/profile.d/*.sh; do
      if [ -r "$i" ]; then
        if [ "$PS1" ]; then
          . "$i"
        else
          . "$i" >/dev/null
        fi
      fi
    done

    unset i
    unset -f pathmunge
  fi
fi
# vim:ts=4:sw=4
